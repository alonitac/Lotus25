# Containers 

## Running your first container

Run the [`postgres`](https://hub.docker.com/_/postgres) container by: 

```bash 
docker pull postgres
docker run -e POSTGRES_PASSWORD=1234 postgres
```

When you run this command, the following happens (assuming you are using the default DockerHub registry configuration):

1. Docker pulls the `postgres` image from DockerHub. 
2. Docker creates a new container from the `postgres` image. The `postgres` image is a ready-to-run container image that encapsulates the [Postgres Database](https://www.postgresql.org/) software, along with its dependencies and configuration. When the image is used to create a container, it provides a fully functional Postgres server environment, without the need to install and configure postgres on your machine.
3. Docker allocates a dedicated read-write filesystem to the container (which is completely different and isolated from the host machine fs). This allows a running container to create or modify files and directories in its local filesystem.
4. Docker starts the container.
5. When you type `CTRL+c` the container stops but is not removed. You can start it again or remove it. When a container is removed, its file system is deleted. 

## Container management and lifecycle

To see your **running** containers, type:

```bash
docker ps 
```

or add  `-a` flag to list also stopped containers:

```console
$ docker ps -a
CONTAINER ID   IMAGE        COMMAND                   CREATED              STATUS                      PORTS       NAMES
d841a2fe07f9   postgres     /usr/bin/entrypoint…         About a minute ago   Exited (0) 14 seconds ago   3000        funny_blackburn
```

In the above output: 

- `d841a2fe07f9` is the **container ID** - a unique identifier assigned to each running container in Docker.
- `/usr/bin/entrypoint…` is the beginning of the actual linux command that has run to initiate the process of the container. 
- `funny_blackburn` is a random alphabetical name that docker assigned to the container. 

### Set environment variables for containers

When running a container using the `docker run` command, you can specify environment variables using the `-e` or `--env` flag.
For example:

```bash
docker run -e POSTGRES_PASSWORD=1234 postgres
```

### Published ports

By default, when you run a container using the `docker run` command, the container doesn't expose any of its ports to the outside world.
To make a port available to services outside of Docker, or to Docker containers running on a different network, use the `--publish` or `-p` flag. 
This creates a firewall rule in the container, mapping a container port to a port on the host machine to the outside world.

Here's an example:

```bash
docker run -e POSTGRES_PASSWORD=1234 -p 5432:5432 postgres
```

`-p 5432:5432` maps port 5432 **in the container** to port 5432 **in the host machine**. 

Install the [Postgres client extension for VSCode](https://marketplace.visualstudio.com/items?itemName=cweijan.vscode-postgresql-client2) and make sure you can connect to your running Postgres container using the following connection details: 

- Host: `localhost`
- Port: `5432`
- User: `postgres`
- Password: `1234`

### Running containers in the background 

When running containers with Docker, you have the option to run them in the background, also known as **detached mode**. This allows containers to run independently of your current terminal session, freeing up your terminal for other tasks.

To run a container in the background, you can use the `-d` or `--detach` flag with the docker run command. 

Let's run another postgres container: 

```console
$ docker run -d --name my-postgres-2 postgres
310f1c48e402648ce4db41817dd76027d4528e481b25e985296fccc83421ddcb
```

When a container is running in the background, Docker assigns a unique container ID and displays it as output. You can use this ID to reference and manage the container later.

To view the list of running containers, you can use the `docker ps` command.
This command lists all the running containers along with their respective container IDs, names, and other information.

Since `my-postgres-2` is running in the background, the `docker logs` command can help you to view the logs generated by a running Docker container.
It allows you to retrieve and display the standard output (stdout) and standard error (stderr) logs generated by the container's processes.


```console
$ docker logs my-postgres-2
....
```

If you want a real-time view, add the `-f` (`--follow`) flag. 

```console
$ docker logs my-postgres-2 -f
...
```

### Killing, stopping, starting and removing containers 

The `docker stop` command is used to stop one or more running containers in Docker.
It **gracefully stops** the containers by sending a `SIGTERM` signal to the main process running inside each container and then waits for a specified timeout (default is 10 seconds) before forcefully terminating them with a `SIGKILL` signal if needed.

```bash
docker container stop my-postgres-2
```

The `docker kill` command is used to forcefully terminate one or more running containers in Docker. It immediately sends a `SIGKILL` signal to the main process running inside each container, causing them to stop abruptly without any graceful shutdown.

Stopped or killed containers can be started using the `docker start` command, which resumes their execution from the point where they were stopped or killed. 
The container retains its configuration and any changes made inside the container's file system prior to stopping.


The `docker rm` command is used to remove one or more stopped or killed containers. 
It allows you to delete containers that are no longer needed, freeing up disk space and cleaning up resources.
It's important to note that the containers you wish to remove must be in a stopped state. If you attempt to remove a running container, you will encounter an error. 

```bash
docker stop my-postgres my-postgres-2
docker rm my-postgres my-postgres-2
docker ps -a 
```

> [!NOTE]
> The state of a container (stopped or killed) does not affect the Docker images associated with it. 
> Docker images remain unchanged and can be used to create and start new containers as needed.

> [!TIP]
> The `--rm` flag in the `docker run` command is used to automatically remove the container when it exits or stops running. It can be handy when you don't want to retain the container after it has served its purpose.
> 
> ```bash
> docker run --rm postgres
> ```


### Inspecting a container 

The `docker inspect` command is used to retrieve detailed information about Docker objects such as containers, images, networks, and volumes. It provides a comprehensive JSON representation of the specified object, including its configuration, network settings, mounted volumes, and more.

The basic syntax for the docker inspect command is:

```bash 
docker inspect [OPTIONS] OBJECT
```

Where `OBJECT` represents the name or ID of the Docker object you want to inspect.


Inspect your running container by:

```console
$ docker inspect my-postgres-2
....
```


### Interacting with containers

In addition to starting a new container with an interactive terminal session using docker run `-it`, you can also interact with **running** containers using the `docker exec` command.

The `docker exec` command allows you to execute a command inside a running container. Here's the basic syntax:

```bash 
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```

Let's see it in action...

Start a new `postgres` container and keep it running. Give it a meaningful name instead the one Docker generates: 

```bash 
docker run --name my-postgres postgres 
```

Make sure the container is up and running. Since the running container occupying your current terminal session, open up another terminal session and execute:

```console
$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES
89cf04f27c04   postgres     /usr/bin/entrypoint…     About a minute ago   Up About a minute   3000/tcp  my-postgres
```

Now say we want to debug the running `postgres` container, and perform some maintenance tasks, or executing specific commands within the containerized environment, we can achieve it by:

```bash 
docker exec -it my-postgres /bin/bash
```

And you're in... You can execute any command you want within the running `my-postgres` container. 

**Tip**: if you don't know the container name, you can `exec` a command also using the container id:

```bash 
docker exec -it 89cf04f27c04 /bin/bash
```

## Docker image vulnerabilities

Docker images contain security vulnerabilities, either by using vulnerable base image, or install insecure package.
Docker image security scanning is a process of identifying known security vulnerabilities in the packages listed in your Docker image.
This gives you the opportunity to find vulnerabilities in container images and fix them before deploying image to production environments.

[Docker Scout](https://docs.docker.com/scout/quickstart/) is a solution for analyzing your images. The free tier allows you to scan up to 3 repositories. 

Follow the [Docker Scout Quickstart](https://docs.docker.com/scout/quickstart/) to familiarize yourself with this tool.  



# Exercises 

### :pencil2: Communication between containers and the internet

Run two [`ubuntu`](https://hub.docker.com/_/ubuntu) containers named `ubuntu1` and `ubuntu2`.
Use the `-it` flags to make an interactive interaction with the running containers using a tty terminal.

Your goal is to be able to successfully `ping` the `ubuntu1` container from `ubuntu2`, i.e. to verify communication between the two containers.
Install ping if needed, `inspect` the containers to discover their IP addresses.

#### :pencil2: Postgres + PGAdmin container 

Run a `Postgres` container and a [`PGAdmin` container](https://hub.docker.com/r/dpage/pgadmin4/).

Connect the `PGAdmin` container to the `Postgres` container so that you can manage the `Postgres` database using the `PGAdmin` web interface.

